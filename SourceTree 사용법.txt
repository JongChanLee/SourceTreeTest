
******[리셋하기 / Reset]******

1. 원하는 버전으로 되돌아가기 (원하는 버전 후에 등록된 버전들은 모두 삭제되는 방법)
-> 원하는 버전을 오른쪽 클릭을 한다.
-> Reset current brunch to this commit을 선택
-> 옵션 중에 hard를 선택 후 OK를 선택
=> Reset을 원하던 버전 후에 등록된 commit들은 모두 삭제되고, 해당 파일 또한 해당 버전에 등록되었던 내용으로 완전히 수정되어진다.
ex)
파일 A가 commit을 1,2,3,4,5 순서로 하였고, 지금 상태가 5라고 하자.
이때 3번에서 hard reset을 하였다면
SourceTree에 남아있는 commit은 1,2,3이고 파일 A의 상태는 3이다.
-> 하나의 버전 안에 파일이 여러개 일 때 유의하자.
  -> 하나의 파일만 되돌리려고 했는데 4번 commit에서 생성된 파일이 삭제되어 날라 갈 수도 있다.


2. 버전들만 삭제하기. (해당 파일의 내용은 바뀌지 않음)
-> commit을 너무 자주해서 중간 과정을 지우고 싶거나, 들어가지 않아야될 내용이 들어갔을 때 하는 방법
-> 원하는 버전을 오른쪽 클릭을 한다.
-> Reset current brunch to this commit을 선택
-> 옵션 중에 mixed를 선택 후 OK를 선택
=> Reset 원하는 버전 후에 등록된 commit들은 모두 삭제되었지만, hard와 다른 것은 해당 파일은 현재 상태를 유지하고 있는다. -> 다시 commit이 가능하다.
ex)
파일 A가 commit을 1,2,3,4,5 순서로 하였고, 지금 상태가 5라고 하자.
이때 3번에서 mixed reset을 하였다면
SourceTree에 남아있는 commit은 1,2,3이고 파일 A의 상태는 5이다.
-> 이때는 SourceTree에 있는 기록만 삭제되는 것이기 때문에 4번 commit에서 파일을 새로 등록 했다고 하더라도, 그 파일은 삭제되지 않는다.
  -> 다시 commit하여 A와 새로운 파일을 버전 등록을 할 수 있다.

******[되돌리기 / Revert ]******
git에서는 Revert인데 SourceTree에서는 Reverse Commit으로 되어있다.

되돌리기란 Commit된 직전의 상태로 다시 되돌리는 것을 말한다.
Reset과는 다르게 되돌려진 상태고 Commit 되어 새로운 버전기록이 하나 생긴다.
1,2,3,4,5 순서로 되어 있을 때, 5상태에서 3으로 Revert하고 싶을 때는
-> 4에서 오른쪽 클릭 [Reverse commit]을 한번 클릭하면
     1,2,3,4,5,Revert "4" 이렇게 새로 생긴다.
-> 다시 3에서 오른쪽 클릭 [Reverse commit]을 클릭하면
     1,2,3,4,5,Revert "4",Revert "3" 이렇게 되어 3의 상태로 되돌아가며 그 기록이 남아있다.
 => 한번에 4를 거치지 않고 3에서 바로 [Reverse commit]을 하면 오류가 난다.

******[브랜치 / Branch]******
브랜치는 나뭇가지 라는 뜻
프로젝트 A가 있다.
이 A에 대해서 여러가지 실험을 하고 싶은데 본래 파일에 하기에는 어려움이 있다.
-> 가장 쉬운 방법으로는 똑같은 프로젝트를 복사하여 그 복사본에 실험을 하는 것이다.
  -> 실험을 하였는데 그 실험이 좋아서 원래 프로젝트에 적용을 시켜야 하는 경우라면?
    -> 이게 어려울수도 있다.
    -> 이걸 Git이 도와준다.


1. 브랜치 생성

메뉴 중에 [Branch]를 선택하여 새로운 브랜치를 만들 수 있다.
  -> 선택 옵션 중에 [Working copy parent]를 선택하면 master가 현재 선택된 브랜치의 위치에 새로운 브랜치를 만든다.
  -> [Specified commit]을 선택하면 원하는 commit위치에 브랜치를 생성 할 수 있다.
-> 옆에 브랜치 목록에 새로 만든 브랜치가 나타난다.
[master]는 기본적으로 주어진 브랜치이다.
-> 브랜치를 새로 만들면 옆의 브랜치 목록에 새로운 브랜치가 추가가 된것을 볼 수 있다.
  -> 해당 브랜치를 더블 클릭하면 저장소 목록(맨 왼쪽)에 현재 선택된 브랜치가 어떤것을 나타내는지를 알 수 있다.
ex) 파일 A
1,2,3,4,<master>5 의 상태에서 [Branch]를 선택하여 새로운 브랜치 <child>를 만들었다고 하자
->  1,2,3,4, <child><master>5 이렇게 목록이 나오는데  <child>가 앞에 있으므로 
      새로운 브랜치를 생성한 직후에는 그 브랜치가 선택이 되어있다는 것을 알 수 있다.
-> 여기서  <master> 를 선택 후 commit을 했다고 하자.
  -> 1,2,3,4, <child>5,6,7, <master>8 로 된다.
  -> 그 다음에는  <child>를 선택해보면,
      master에는 8의 상태이지만,  child는 5의 상태를 띄고 있다.
         -> A를 띄워 놓고 master를 더블 클릭하면 파일은 A는 현재 8의 상태로 되어있다.
         -> 하지만 A를 띄워놓고 child 를 더블 클릭하면 A는 5의 상태로 나타난다.
      		=> 폴더를 복사해서 두개를 따로 만든 것이 아니다. -> 폴더 하나에 A도 한개이다.
		=> 이러한 관리를 git이 해준다.
  ->  <child>를 선택한 상태에서 commit을 해보면
  -> 1,2,3,4,5,6,7, <master>8,  <child>9 로 되어있다.
  -> SourceTree의 Graph 항목을 보면 나뭇가지 처럼 뻗어 나간 것을 확인 할 수 있다.
  -> 8의 부모는 7654321이고, 9의 부모는 54321이다.
  -> 9에는 8의 내용이 추가가 되어 있지 않다.
=========> 이러한 과정을 할 수 있는 것은 브랜치 때문이다

2. 브랜치 병합 [Merge]

(위의 예제를 그대로 사용)

	   6,7,<master>8
1,2,3,4,5,
	                <child>9
이러한 예제이다.
이 때 child를 master에 합치고 싶다면,
-> <master>를 더블클릭한다.(Check out한다고 표현한다.)
-> 브랜치 목록에서 <child>에 오른쪽 클릭을 하여 [Merge Child into current branch]를 클릭한다. 
   -> 이는 child를 현재 체크아웃된 브랜치 즉, master에 합치겠다는 것이다.
-> 각각에서 수정된 내용이 합쳐져서 새로운 commit이 생긴다.
	   6,7,8          <master>10(Merge branch 'child')
1,2,3,4,5,		 /
	         <child>9
이렇게 되며 Graph 부분을 보면 선이 연결된다. 
-> 또한 Merge를 하였지만 child 브랜치가 사라지진 않는다.
  => 어렵다

3. 브랜치 충돌 해결 (Complict)

충돌이 이러나는 이유는
두개의 서로 다른 브랜치가 하나의 파일에서 같은 위치를 변경 하고 머지 하였기 때문에 나온다.
이때는 머지가 정상적으로 되지 않으며, 일단 병합은 하는데 git이 자동적으로 두개를 동시에 넣고 구분을 해줘서
사람이 선택하도록 하게 만들어준다.
기호 (=,<,>)
<<<<<<<<< HEAD 는 현재 check out되어 있는 브랜치의 내용

>>>>>>>>> child 는 merge 당한 브랜치

========= 를 기준으로 판단하여 위는 head의 내용, 밑에는 merge당하는 브랜치의 내용이다.
이를 보고 사람이 직접 한쪽만 사용 할 것인지, 두가지 다 사용할 것인지를 판단하여 저장할 수 있다.
-> 그다음에 해결할 것이 하나 더 있는데
파일을 저장 후 버전 등록을 위해 Commit을 하려고 보면 아이콘이 노란색 배경에 느낌표가 나온것을볼수 있다.
   이는 Conflict가 났다는 표시이며 이를 오른쪽 클릭하여 [Resolve Confilicts] - [Mark Resolved]를 선택한다.
		-------> [Resolve Confilicts]를 들어가서 옵션에서 [Resolve Using 'Mine'] 이나 [Resolve Using 'Theirs'] 둘중에 하나를 선택하면
			     Check out된 것의 내용을 남기거나, merge할 브랜치의 내용으로 바꾸거나 둘중의 하나를 자동으로 해주는 것이다.
     -> git에게 충돌을 해결 했다는 것을 알려주는 것이다.
 Mark Resolved를 선택하여 충돌을 해결 한 후에 Commit을 다시 해주면 된다.
=> Commit을 하려고 보면 Commit내용을 git이 자동으로 로그를 입력해준다. 바꿀 수 도 있다.

4. 충돌을 해결 하는 방법

<master> 이미 출시되어 상용화 되고 있다고 할 때,
새로운 기능을 위해 <child>를 개발하고 있다고 하자.
3개월 뒤에 child의 기능을 master에 넣으려고 하는데,
그 3개월 동안 master의 오류 개선등을 위해 master의 내용도 수정이 되어있다면
merge하는 과정에서 충돌이 일어 날 수 있다. 
 --> 이때 굉장히 큰 충돌일 수도 있으며, 해결하기가 힘들수도 있다.

-> 이를 해결하는 하나의 방법으로는
child를 개발하는 동안, master의 내용을 주기적으로 merge해주는 것이다.
나중에는 master에 child를 merge하겠지만 (check out된 것은 master)
그 사이 사이에 child에 master를 merge해주는 것이다. (check out 된 것은 merge)

이렇게 하면 충돌이 아예 막아지는 것은 아니지만,
충돌의 크기가 작아저서 해결하기가 한결 편해진다.
--> 그러나 이러한 일은 별로 없을 거라고 한다...... 
